My first thought was to just directly compare the frequency of the encrypted text to the frequency of letters in english. I then checked the "decrypted" text against nltk's list of words. This did not work, so I thought about going through the permutations that were close, but that felt like getting a bit close to 26! and I was not sure the best way to do that anyway.
I decided to switch my strategy to a recursive algorithm which guesses each word in order, checking that they are consistent with the already guessed mapping. If they were not then I would discard the guessed word and try with the next guessed word. I continue doing this until either I reach the end of the text, or I reach the end of the word list. The first mistake I realized was not checking that it was one to one, this caused problems and inflated the calculation time. The next mistake I realized was forgetting to remove punctuation, this caused a bunch of wasted calculation time. The third mistake I realized was that the nltk's list of words was not comprehensive enough for my purposes, i.e. there were words which could be in the answer which were not in the list, so I switched to a more comprehensive list I found at https://github.com/dwyl/english-words/tree/master. I used https://planetcalc.com/8047/ to know when things went wrong.
After finding the decrypted text and the map, I ran through every password in the dictionary, like I did with users 1-6.
In retrospect, I should have done this with frequency analysis with letter pairings, but semi-brute-force worked. Honestly, plain brute force might have been faster...
In the end it took 27648.7 seconds (7.68 hours) to find the mapping of {'b': 'a', 'p': 'l', 's': 't', 'm': 'h', 'f': 'e', 'x': 'v', 'c': 'r', 'd': 'i', 'k': 'y', 'w': 'c', 'g': 'm', 'r': 'b', 'e': 'u', 'j': 'o', 'q': 'f', 't': 's', 'l': 'd', 'n': 'p', 'i': 'g', 'v': 'n', 'u': 'w', 'y': 'k', 'h': 'q', 'o': 'x'}. It took 0.05 seconds to find the password once the map was found.